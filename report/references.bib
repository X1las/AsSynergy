@web_page{mscodes,
    key = {mscodes},
    journal = {Ms.Codes},
    title = {CPU Clock Speed History Graph},
    url = {https://ms.codes/blogs/computer-hardware/cpu-clock-speed-history-graph},
    year = {2025},
}

@web_page{Mattson2014,
   author = {Pär Mattson},
   journal = {Comsol},
   title = {Why Haven’t CPU Clock Speeds Increased in the Last Few Years? | COMSOL Blog},
   url = {https://www.comsol.com/blogs/havent-cpu-clock-speeds-increased-last-years},
   year = {2014},
}

@web_page{Thomas2025,
   author = {Jacqueline Thomas},
   journal = {IGN},
   title = {Best CPU 2025: Pick the Right Processor for Your Gaming PC},
   url = {https://www.ign.com/articles/the-best-cpus-for-gaming},
   year = {2025},
}

@book{Rauber2023,
   author = {Thomas Rauber and Gudula Rünger},
   edition = {Third},
   publisher = {Springer},
   title = {Parallel Programming for Multicore and Cluster Systems},
   year = {2023},
}

@techReport{Ghose2024,
   author = {Saugata Ghose},
   institution = {University of Illinois},
   month = {8},
   title = {General-Purpose Multicore Architectures},
   year = {2024}
}

@techReport{Sun2019,
   abstract = {Moore's Law and Dennard Scaling have guided the semiconductor industry for the past few decades. Recently, both laws have faced validity challenges as transistor sizes approach the practical limits of physics. We are interested in testing the validity of these laws and reflect on the reasons responsible. In this work, we collect data of more than 4000 publicly-available CPU and GPU products. We find that transistor scaling remains critical in keeping the laws valid. However, architectural solutions have become increasingly important and will play a larger role in the future. We observe that GPUs consistently deliver higher performance than CPUs. GPU performance continues to rise because of increases in GPU frequency, improvements in the thermal design power (TDP), and growth in die size. But we also see the ratio of GPU to CPU performance moving closer to parity, thanks to new SIMD extensions on CPUs and increased CPU core counts.},
   author = {Yifan Sun and Nicolas Bohm Agostini and Shi Dong and David Kaeli},
   institution = {Northeastern University},
   month = {11},
   title = {Summarizing CPU and GPU Design Trends with Product Data},
   url = {www.techpowerup.com,},
   year = {2019}
}

@misc{Smith2023,
   author = {Eric Smith},
   month = {1},
   title = {Updated AMD EPYC and Intel Xeon Core Counts Over Time},
   url = {https://www.servethehome.com/updated-amd-epyc-and-intel-xeon-core-counts-over-time},
   year = {2023}
}

@article{Johnson2015,
   abstract = {Overall performance of computer systems are better investigated and evaluated when its various components are considered, components such as the hardware, software and firmware. The comparative analysis of single-core and multi-core systems was carried out using Intel Pentium G640T 2.4GHz dual-core, Intel Pentium IV 2.4GHz single-core and Intel Pentium IV 2.8GHz single-core systems. The approach method was using hi-tech benchmarking and stress testing software(s) to examine systems' CPU and RAM for performance and stability. In all the tests, the components of dual-core had better rating when compared with single-core components; GFLOP result, and execution time for various processes rank G640T 2.4GHz dual-core above Pentium IV 2.4GHz and 2.8GHz single-core respectively.},
   author = {Ogundairo Johnson and Omosehinmi Dinyo},
   doi = {10.5121/ijcsit.2015.7610},
   issn = {09754660},
   issue = {6},
   journal = {International Journal of Computer Science and Information Technology},
   month = {12},
   pages = {117-130},
   publisher = {Academy and Industry Research Collaboration Center (AIRCC)},
   title = {Comparative Analysis of Single-Core and Multi-Core Systems},
   volume = {7},
   year = {2015}
}

@article{Rajsbaum2020,
   abstract = {Modern computing systems are highly concurrent. Threads run concurrently in shared-memory multi-core systems, and programs run in different servers communicating by sending messages to each other. Concurrent programming is hard because it requires to cope with many possible, unpredictable behaviors of the processes, and the communication media. The article argues that right from the start in 1960's, the main way of dealing with concurrency has been by reduction to sequential reasoning. It traces this history, and illustrates it through several examples, from early ideas based on mutual exclusion (which was initially introduced to access shared physical resources), passing through consensus and concurrent objects (which are immaterial data), until today distributed ledgers. A discussion is also presented, which addresses the limits that this approach encounters, related to fault-tolerance, performance, and inherently concurrent problems. .},
   author = {Sergio Rajsbaum and Michel Raynal},
   doi = {10.1145/3406678.3406690ï},
   issue = {2},
   journal = {ACM SIGACT News},
   keywords = {Agreement,Asynchrony,Atomicity,Concurrent object,Consensus,Consistency con-dition,Crash failure,Fault-tolerance,Ledger,Linearizability,Message-passing,Mutual exclusion,Progress condition,Read/write register,Sequential specification,Sequential thinking,State machine replication,Synchronization,Total order broadcast,Universal construction},
   pages = {59-88},
   title = {Years of Mastering Concurrent Computing through Sequential Thinking},
   volume = {2020},
   url = {https://hal.science/hal-03162635v1},
   year = {2020}
}

@article{Pyeatt2020,
   author = {Larry D. Pyeatt and William Ughetta},
   doi = {10.1016/B978-0-12-819221-4.00012-2},
   journal = {ARM 64-Bit Assembly Language},
   pages = {113-153},
   publisher = {Elsevier},
   title = {Structured programming},
   url = {https://linkinghub.elsevier.com/retrieve/pii/B9780128192214000122},
   year = {2020}
}

@article{DeMouna2009,
   abstract = {This article advocates the revival of coroutines as a convenient general control abstraction. After proposing a new classification of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise definition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and one-shot delimited continuations. We also show that full asymmetric coroutines and one-shot delimited continuations have many similarities, and therefore present comparable benefits. Nevertheless, coroutines are easier implemented and understood, especially in the realm of procedural languages. © 2009 ACM.},
   author = {Ana Lúcia De Moura and Roberto Ierusalimschy},
   doi = {10.1145/1462166.1462167},
   issn = {01640925},
   issue = {2},
   journal = {ACM Transactions on Programming Languages and Systems},
   keywords = {Continuations,Generators,Multitasking},
   month = {2},
   title = {Revisiting coroutines},
   volume = {31},
   url = {https://www.researchgate.net/publication/2934331_Revisiting_Coroutines},
   year = {2009}
}

@book{Anthony2016,
   abstract = {This chapter examines systems and communication within systems from the process viewpoint. The process is the central theme around which the concepts of modular systems and multiple communicating systems are presented and explained. Process scheduling and management are examined for both real-time and non-real-time applications. Communication is treated as input to and output from processes. The way that interprocess communication is facilitated, and the way that communication behavior may interact with process scheduling behavior, is discussed. Multithreading is introduced and discussed in terms of ensuring responsiveness of processes. The use of timers within processes to provide control and generate periodic tasks is investigated.},
   author = {Richard John Anthony},
   doi = {10.1016/B978-0-12-800729-7.00002-9},
   journal = {Systems Programming},
   pages = {21-106},
   publisher = {Elsevier},
   title = {The Process View},
   year = {2016}
}

@misc{POSIXDocs,
   publisher = {The Open Group},
   month = {1},
   day = {2},
   title = {POSIX Documentation},
   url = {https://pubs.opengroup.org/onlinepubs/9799919799/},
   year = {2025},
   accessed = {18-05-2025}
}

@misc{GNUPOSIX,
   publisher = {GNU},
   title = {POSIX (The GNU C Library)},
   url = {https://www.gnu.org/software/libc/manual/html_node/POSIX.html},
   accessed = {18-05-2025}
}

@book{Stevens2005,
   abstract = {2nd ed. Rago carefully retains the spirit and approach that made this book a classic. Building on Stevens' work, he begins with basic topics such as files, directories, and processes, carefully laying the groundwork for understanding more advanced techniques, such as signal handling and terminal I/O. Substantial new material includes chapters on threads and multithreaded programming, using the socket interface to drive interprocess communication (IPC), and extensive coverage of the interfaces added to the latest version of the POSIX. 1 standard. Nearly all examples have been tested on four of today's most widely used UNIX/Linux platforms: FreeBSD 5.2.1; the Linux 2.4.22 kernel; Solaris 9; and Darwin 7.4.0, the FreeBSD/Mach hybrid underlying Apple's Mac OS X 10.3. As in the first edition, you'll learn through example, including more than 10,000 lines of downloadable, ANSI C source code. More than 400 system calls and functions are demonstrated with concise, complete programs that clearly illustrate their usage, arguments, and return values. To tie together what you've learned, the book presents several chapter-length case studies, each fully updated for contemporary environments. Advanced Programming in the UNIX® Environment has helped ageneration of programmers write code with exceptional power, performance, and reliability. Now updated for today's UNIX/Linux systems, this second edition will be even more indispensable. UNIX System Overview -- UNIX Standardization and Implementations -- File I/O -- Files and Directories -- Standard I/O Library -- System Data Files and Information -- Process Environment -- Process Control -- Process Relationships -- Signals -- Threads -- Thread Control -- Daemon Processes -- Advanced I/O -- Interprocess Communication -- Network IPC: Sockets -- Advanced IPC -- Terminal I/O -- Pseudo Terminals -- A Database Library -- Communicating with a Network Printer.},
   author = {W. Richard. Stevens and Stephen A.. Rago},
   isbn = {0201433079},
   pages = {927},
   publisher = {Addison-Wesley},
   title = {Advanced programming in the Unix environment},
   year = {2005}
}

@misc{PthreadDocs,
   publisher = {The Open Group},
   title = {Pthread.h - threads},
   url = {https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html},
   accessed = {20-05-2025}
}

@article{Wagner2022,
   author = {Bill Wagner and Pooja Poojari and Genevieve Warren and Dennis Lee},
   journal = {Microsoft},
   title = {Using threads and threading - .NET | Microsoft Learn},
   url = {https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading},
   year = {2022}
}

@article{Harbour2003,
   abstract = {The POSIX standard defines a portable interface for UNIX-based operating systems. The goal of this increasingly important standard is source-level portability of applications. In this paper we discuss the real-time extensions to POSIX and how these extensions address the needs of applications with real-time requirements.},
   author = {Michael González Harbour},
   journal = {University of Cantabria},
   month = {11},
   title = {REAL-TIME POSIX: AN OVERVIEW},
   year = {2003}
}

@misc{CSThreadClass,
   publisher = {Microsoft},
   title = {Thread Class - System.Threading},
   url = {https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread?view=net-9.0},
   accessed = {20-05-2025}
}

@misc{CSProcessorAffinity,
   publisher = {Microsoft},
   title = {Processor Affinity Property - ProcessThread.ProcessorAffinity - System.Diagnostics},
   url = {https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.processthread.processoraffinity?view=net-9.0},
   accessed = {20-05-2025}
}

@misc{PythonFAQ,
   publisher = {The Python Software Foundation},
   title = {General Python FAQ — Python 3.13.3 documentation},
   url = {https://docs.python.org/3/faq/general.html},
   accessed = {20-05-2025}
}

@misc{PythonGIL,
   publisher = {The Python Software Foundation},
   title = {Global Interpreter Lock - Python Wiki},
   url = {https://wiki.python.org/moin/GlobalInterpreterLock},
   accessed = {21-05-2025}
}

@misc{PythonMultiprocessing,
   publisher = {The Python Software Foundation},
   title = {Multiprocessing — Process-based parallelism — Python 3.13.3 documentation},
   url = {https://docs.python.org/3/library/multiprocessing.html},
   accessed = {21-05-2025}
}

@misc{PythonThreading,
   publisher = {The Python Software Foundation},
   title = {Threading — Thread-based parallelism — Python 3.13.3 documentation},
   url = {https://docs.python.org/3/library/threading.html},
   accessed = {21-05-2025}
}

@misc{JavaThreadClass,
   publisher = {Oracle},
   title = {Class Thread - Java Platform SE 8},
   url = {https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html},
   accessed = {21-05-2025}
}

