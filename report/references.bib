@web_page{mscodes,
    key = {mscodes},
    journal = {Ms.Codes},
    title = {CPU Clock Speed History Graph},
    url = {https://ms.codes/blogs/computer-hardware/cpu-clock-speed-history-graph},
    year = {2025},
}

@web_page{Mattson2014,
   author = {Pär Mattson},
   journal = {Comsol},
   title = {Why Haven’t CPU Clock Speeds Increased in the Last Few Years? | COMSOL Blog},
   url = {https://www.comsol.com/blogs/havent-cpu-clock-speeds-increased-last-years},
   year = {2014},
}

@web_page{Thomas2025,
   author = {Jacqueline Thomas},
   journal = {IGN},
   title = {Best CPU 2025: Pick the Right Processor for Your Gaming PC},
   url = {https://www.ign.com/articles/the-best-cpus-for-gaming},
   year = {2025},
}

@book{Rauber2023,
   author = {Thomas Rauber and Gudula Rünger},
   edition = {Third},
   publisher = {Springer},
   title = {Parallel Programming for Multicore and Cluster Systems},
   year = {2023},
}

@techReport{Ghose2024,
   author = {Saugata Ghose},
   institution = {University of Illinois},
   month = {8},
   title = {General-Purpose Multicore Architectures},
   year = {2024}
}

@techReport{Sun2019,
   abstract = {Moore's Law and Dennard Scaling have guided the semiconductor industry for the past few decades. Recently, both laws have faced validity challenges as transistor sizes approach the practical limits of physics. We are interested in testing the validity of these laws and reflect on the reasons responsible. In this work, we collect data of more than 4000 publicly-available CPU and GPU products. We find that transistor scaling remains critical in keeping the laws valid. However, architectural solutions have become increasingly important and will play a larger role in the future. We observe that GPUs consistently deliver higher performance than CPUs. GPU performance continues to rise because of increases in GPU frequency, improvements in the thermal design power (TDP), and growth in die size. But we also see the ratio of GPU to CPU performance moving closer to parity, thanks to new SIMD extensions on CPUs and increased CPU core counts.},
   author = {Yifan Sun and Nicolas Bohm Agostini and Shi Dong and David Kaeli},
   institution = {Northeastern University},
   month = {11},
   title = {Summarizing CPU and GPU Design Trends with Product Data},
   url = {www.techpowerup.com,},
   year = {2019}
}

@misc{Smith2023,
   author = {Eric Smith},
   month = {1},
   title = {Updated AMD EPYC and Intel Xeon Core Counts Over Time},
   url = {https://www.servethehome.com/updated-amd-epyc-and-intel-xeon-core-counts-over-time},
   year = {2023}
}

@article{Johnson2015,
   abstract = {Overall performance of computer systems are better investigated and evaluated when its various components are considered, components such as the hardware, software and firmware. The comparative analysis of single-core and multi-core systems was carried out using Intel Pentium G640T 2.4GHz dual-core, Intel Pentium IV 2.4GHz single-core and Intel Pentium IV 2.8GHz single-core systems. The approach method was using hi-tech benchmarking and stress testing software(s) to examine systems' CPU and RAM for performance and stability. In all the tests, the components of dual-core had better rating when compared with single-core components; GFLOP result, and execution time for various processes rank G640T 2.4GHz dual-core above Pentium IV 2.4GHz and 2.8GHz single-core respectively.},
   author = {Ogundairo Johnson and Omosehinmi Dinyo},
   doi = {10.5121/ijcsit.2015.7610},
   issn = {09754660},
   issue = {6},
   journal = {International Journal of Computer Science and Information Technology},
   month = {12},
   pages = {117-130},
   publisher = {Academy and Industry Research Collaboration Center (AIRCC)},
   title = {Comparative Analysis of Single-Core and Multi-Core Systems},
   volume = {7},
   year = {2015}
}

@article{Rajsbaum2020,
   abstract = {Modern computing systems are highly concurrent. Threads run concurrently in shared-memory multi-core systems, and programs run in different servers communicating by sending messages to each other. Concurrent programming is hard because it requires to cope with many possible, unpredictable behaviors of the processes, and the communication media. The article argues that right from the start in 1960's, the main way of dealing with concurrency has been by reduction to sequential reasoning. It traces this history, and illustrates it through several examples, from early ideas based on mutual exclusion (which was initially introduced to access shared physical resources), passing through consensus and concurrent objects (which are immaterial data), until today distributed ledgers. A discussion is also presented, which addresses the limits that this approach encounters, related to fault-tolerance, performance, and inherently concurrent problems. .},
   author = {Sergio Rajsbaum and Michel Raynal},
   doi = {10.1145/3406678.3406690ï},
   issue = {2},
   journal = {ACM SIGACT News},
   keywords = {Agreement,Asynchrony,Atomicity,Concurrent object,Consensus,Consistency con-dition,Crash failure,Fault-tolerance,Ledger,Linearizability,Message-passing,Mutual exclusion,Progress condition,Read/write register,Sequential specification,Sequential thinking,State machine replication,Synchronization,Total order broadcast,Universal construction},
   pages = {59-88},
   title = {Years of Mastering Concurrent Computing through Sequential Thinking},
   volume = {2020},
   url = {https://hal.science/hal-03162635v1},
   year = {2020}
}

@article{Pyeatt2020,
   author = {Larry D. Pyeatt and William Ughetta},
   doi = {10.1016/B978-0-12-819221-4.00012-2},
   journal = {ARM 64-Bit Assembly Language},
   pages = {113-153},
   publisher = {Elsevier},
   title = {Structured programming},
   url = {https://linkinghub.elsevier.com/retrieve/pii/B9780128192214000122},
   year = {2020}
}

@article{DeMouna2009,
   abstract = {This article advocates the revival of coroutines as a convenient general control abstraction. After proposing a new classification of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise definition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and one-shot delimited continuations. We also show that full asymmetric coroutines and one-shot delimited continuations have many similarities, and therefore present comparable benefits. Nevertheless, coroutines are easier implemented and understood, especially in the realm of procedural languages. © 2009 ACM.},
   author = {Ana Lúcia De Moura and Roberto Ierusalimschy},
   doi = {10.1145/1462166.1462167},
   issn = {01640925},
   issue = {2},
   journal = {ACM Transactions on Programming Languages and Systems},
   keywords = {Continuations,Generators,Multitasking},
   month = {2},
   title = {Revisiting coroutines},
   volume = {31},
   url = {https://www.researchgate.net/publication/2934331_Revisiting_Coroutines},
   year = {2009}
}

@book{Anthony2016,
   abstract = {This chapter examines systems and communication within systems from the process viewpoint. The process is the central theme around which the concepts of modular systems and multiple communicating systems are presented and explained. Process scheduling and management are examined for both real-time and non-real-time applications. Communication is treated as input to and output from processes. The way that interprocess communication is facilitated, and the way that communication behavior may interact with process scheduling behavior, is discussed. Multithreading is introduced and discussed in terms of ensuring responsiveness of processes. The use of timers within processes to provide control and generate periodic tasks is investigated.},
   author = {Richard John Anthony},
   doi = {10.1016/B978-0-12-800729-7.00002-9},
   journal = {Systems Programming},
   pages = {21-106},
   publisher = {Elsevier},
   title = {The Process View},
   year = {2016}
}

@misc{Open2025,
   author = {TheOpenGroup},
   journal = {The Open Group},
   month = {1},
   title = {POSIX Documentation},
   url = {https://pubs.opengroup.org/onlinepubs/9799919799/},
   year = {2025}
}

@misc{GNU2025,
   author = {GNU},
   title = {POSIX (The GNU C Library)},
   url = {https://www.gnu.org/software/libc/manual/html_node/POSIX.html}
}
